# Семинар 5. Стабилизация масок и propagation-baseline

Цель семинара — реализовать простой baseline видеосегментации, основанный на переносе маски через оптический поток и временном сглаживании, а затем исследовать устойчивость такой системы на реальном видеоролике.

---

## 0. Предварительные условия

1. Необходимо подготовить рабочую директорию, содержащую:
   - видеофайл `input.mp4`;
   - маску первого кадра `mask0.png` (чёрно-белое изображение, где объект помечен белым).
2. Должны быть установлены:
   - Python 3.9+;
   - библиотеки для работы с изображением и массивами (`opencv-python`, `numpy`, при желании `matplotlib`, `torch`).
3. Необходимо уметь запускать Python-скрипты из командной строки.

---

## 1. Подготовить структуру проекта

Необходимо создать следующую структуру:

```bash
vos_seminar5/
  main.py          # запуск эксперимента
  io_utils.py      # работа с видео и маской
  flow_utils.py    # расчёт оптического потока
  mask_utils.py    # перенос и сглаживание масок
  vis_utils.py     # визуализация (по желанию)
  input.mp4
  mask0.png
  README.md
````

Файл `README.md` должен кратко описывать, как запускать код и что именно делает ваш baseline.

---

## 2. Загрузка видеокадров и маски

### 2.1. Загрузка видео

В файле `io_utils.py` необходимо реализовать функцию загрузки всех кадров видео в список.

```python
# io_utils.py

def load_video_frames(video_path):
    """
    Необходимо реализовать загрузку всех кадров из видео.

    Требования:
    - Открыть видео по пути video_path.
    - Последовательно прочитать все кадры до конца файла.
    - Сохранить кадры в список (в формате numpy-массивов).
    - Вернуть список кадров.

    Дополнительно:
    - Можно конвертировать кадры в RGB, если это необходимо для дальнейшей обработки.
    """
    # TODO: реализовать
    raise NotImplementedError
```

### 2.2. Загрузка маски первого кадра

```python
# io_utils.py

def load_initial_mask(mask_path):
    """
    Необходимо реализовать загрузку маски первого кадра.

    Требования:
    - Загрузить изображение маски в градациях серого.
    - Привести значения к диапазону [0, 1] (тип float).
    - Убедиться, что размер маски совпадает с размером первого кадра видео
      (проверка размерностей будет выполняться в main.py).

    Дополнительно:
    - Можно реализовать простую проверку и выброс исключения при несоответствии размеров.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---

## 3. Расчёт оптического потока между кадрами

В файле `flow_utils.py` необходимо реализовать функцию расчёта плотного оптического потока между двумя соседними кадрами.

```python
# flow_utils.py

def compute_dense_flow(frame_prev, frame_next):
    """
    Необходимо реализовать расчёт плотного оптического потока между двумя кадрами.

    Требования:
    - На вход подаются два соседних кадра видео (frame_prev, frame_next) в виде numpy-массивов.
    - Кадры следует привести к формату, удобному для выбранного метода оптического потока
      (например, в оттенки серого).
    - На выходе должен быть массив flow формы (H, W, 2), где:
        flow[..., 0] --- горизонтальная компонента смещения,
        flow[..., 1] --- вертикальная компонента смещения.

    Дополнительно:
    - Разрешается использовать любой метод: Farneback, Lucas-Kanade, DNN-подходы и т.д.
    - Важно последовательно использовать один и тот же метод во всём видео.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---

## 4. Перенос маски по оптическому потоку (warping)

В файле `mask_utils.py` необходимо реализовать функцию переноса маски на следующий кадр с использованием оптического потока.

```python
# mask_utils.py

def warp_mask(mask_prev, flow):
    """
    Необходимо реализовать перенос маски mask_prev на следующий кадр с помощью оптического потока.

    Входные данные:
    - mask_prev: вероятностная маска на предыдущем кадре, numpy-массив формы (H, W) с типом float.
    - flow: оптический поток от предыдущего кадра к следующему, numpy-массив формы (H, W, 2).

    Требования:
    - Использовать значения потока для того, чтобы узнать, откуда "пришёл" каждый пиксель нового кадра.
    - Выполнить интерполяцию значений маски (bilinear или ближайший сосед), чтобы получить
      непрерывную маску на новом кадре.
    - Вернуть новую вероятностную маску той же формы (H, W), что и mask_prev.

    Дополнительно:
    - Разрешается использовать любые библиотеки и функции интерполяции, доступные в окружении.
    - Важно корректно согласовать систему координат маски и потока.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---

## 5. Временное сглаживание маски (temporal smoothing)

Также в `mask_utils.py` необходимо реализовать функцию, выполняющую сглаживание маски по времени.

```python
# mask_utils.py

def smooth_mask(mask_prev_smooth, mask_current_warped, beta=0.7):
    """
    Необходимо реализовать временное сглаживание масок.

    Входные данные:
    - mask_prev_smooth: сглаженная маска предыдущего кадра (H, W).
    - mask_current_warped: маска текущего кадра, полученная переносом (H, W).
    - beta: коэффициент сглаживания в диапазоне (0, 1).

    Требования:
    - Реализовать схему сглаживания, учитывающую как текущую, так и предыдущую маску.
    - Обеспечить, чтобы результат оставался в диапазоне [0, 1].
    - Вернуть сглаженную маску для текущего кадра.

    Дополнительно:
    - Необходимо поэкспериментировать с параметром beta и описать влияние этого параметра в отчёте.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---

## 6. Метрика стабильности масок

В `mask_utils.py` требуется добавить функцию оценки межкадровой стабильности.

```python
# mask_utils.py

def compute_temporal_stability(masks):
    """
    Необходимо реализовать метрику временной стабильности масок.

    Входные данные:
    - masks: список или массив вероятностных масок для последовательности кадров (T, H, W).

    Требования:
    - Определить и реализовать метрику, которая измеряет, насколько маски меняются от кадра к кадру.
      Пример идеи: усреднённая по времени и пространству величина |M_t - M_{t-1}|.
    - Метрика должна возвращать одно число, чем оно меньше, тем система стабильнее.

    Дополнительно:
    - Формула метрики, выбранной вами, должна быть явно выписана и описана в отчёте.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---

## 7. Основной сценарий эксперимента

В файле `main.py` необходимо собрать pipeline видеосегментации на основе propagation.

```python
# main.py

from io_utils import load_video_frames, load_initial_mask
from flow_utils import compute_dense_flow
from mask_utils import warp_mask, smooth_mask, compute_temporal_stability

def run_vos_baseline(video_path, mask_path, beta=0.7):
    """
    Необходимо реализовать базовый pipeline видеосегментации.

    Требования:
    1. Загрузить все кадры видео.
    2. Загрузить маску первого кадра и проверить соответствие размеров.
    3. Инициализировать:
       - текущую маску как маску первого кадра,
       - сглаженную маску как маску первого кадра.
    4. Для каждого следующего кадра:
       - вычислить оптический поток между предыдущим и текущим кадром;
       - перенести сглаженную маску с помощью warp_mask;
       - обновить сглаженную маску с помощью smooth_mask;
       - сохранить текущую сглаженную маску в список результатов.
    5. По завершении:
       - вычислить метрику стабильности по всей последовательности масок;
       - вывести значение метрики в консоль.

    Дополнительно:
    - Можно сохранить полученные маски на диск или визуализировать их.
    """
    # TODO: реализовать
    raise NotImplementedError


if __name__ == "__main__":
    # Необходимо задать пути к видео и маске (либо через аргументы командной строки, либо жестко в коде).
    # Затем вызвать run_vos_baseline с выбранным параметром beta.
    # TODO: реализовать интерфейс запуска
    raise NotImplementedError
```

---

## 8. Визуализация результатов (опционально, но рекомендуется)

В файле `vis_utils.py` можно реализовать функции для визуализации:

* наложение маски на кадр;
* отображение разности масок между соседними кадрами;
* сохранение анимации в видеофайл или GIF.

Структура файла может быть любой, но в отчёте необходимо привести примеры визуализаций.

```python
# vis_utils.py

def overlay_mask_on_frame(frame, mask):
    """
    Необходимо реализовать визуализацию: наложение маски на кадр.

    Требования:
    - Визуально выделить область объекта (например, полупрозрачным цветом).
    - Вернуть изображение для отображения или сохранения.
    """
    # TODO: реализовать
    raise NotImplementedError
```

---
